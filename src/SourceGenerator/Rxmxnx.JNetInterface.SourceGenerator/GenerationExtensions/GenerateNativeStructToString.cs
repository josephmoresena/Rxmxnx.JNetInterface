using System;
using System.Runtime.CompilerServices;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Rxmxnx.JNetInterface.SourceGenerator;

internal static partial class GenerationExtensions
{
	private const String NativeToStringFormat = @"#nullable enable
// <auto-generated/>
namespace {0};

partial struct {1} 
{{
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public override String ToString() => $""{{{1}.Type.GetTypeName()}}: {{{2}(this)}}"";
}}
#nullable restore";

	/// <summary>
	/// Generates overrides for <see cref="Object.ToString()"/> for natives structures.
	/// </summary>
	/// <param name="nativeSymbol">A type symbol of native structure.</param>
	/// <param name="context">Generation context.</param>
	/// <param name="isPointer">Indicates whether type symbol i.</param>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void GenerateNativeStructToString(this ISymbol nativeSymbol, SourceProductionContext context,
		Boolean isPointer)
	{
		if (nativeSymbol.Name == "VirtualMachineInitArgumentValue") return;
		String fileName = $"{nativeSymbol.Name}.ToString.g.cs";
		String getTextValueName = !isPointer ? "INativeType.GetTextValue" : "INativeType.GetPointerText";
		String source = String.Format(GenerationExtensions.NativeToStringFormat, nativeSymbol.ContainingNamespace,
		                              nativeSymbol.Name, getTextValueName);
#pragma warning disable RS1035
		context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
#pragma warning restore RS1035
	}
}