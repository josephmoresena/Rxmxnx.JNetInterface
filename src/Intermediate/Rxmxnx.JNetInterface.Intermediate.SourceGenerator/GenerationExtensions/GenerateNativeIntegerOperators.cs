using System;
using System.Runtime.CompilerServices;

using Microsoft.CodeAnalysis;

namespace Rxmxnx.JNetInterface.SourceGenerator;

internal static partial class GenerationExtensions
{
	private const String numericIntegerOperatorsFormat = @"#nullable enable
// <auto-generated/>
namespace {0};

partial struct {1} : IBinaryInteger<{1}>
{{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	Int32 IBinaryInteger<{1}>.GetByteCount() => sizeof({2});
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	Boolean IBinaryInteger<{1}>.TryWriteBigEndian(Span<Byte> destination, out Int32 bytesWritten)
		=> IPrimitiveInteger<{1}, {2}>.TryWriteBigEndian(this._value, destination, out bytesWritten);
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	Boolean IBinaryInteger<{1}>.TryWriteLittleEndian(Span<Byte> destination, out Int32 bytesWritten)
		=> IPrimitiveInteger<{1}, {2}>.TryWriteLittleEndian(this._value, destination, out bytesWritten);
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	Int32 IBinaryInteger<{1}>.GetShortestBitLength()
		=> IPrimitiveInteger<{1}, {2}>.GetShortestBitLength(this._value);
{3}
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static Boolean IBinaryInteger<{1}>.TryReadBigEndian(ReadOnlySpan<Byte> source, Boolean isUnsigned, out {1} value)
		=> IPrimitiveInteger<{1}, {2}>.TryReadBigEndian(source, isUnsigned, out value);
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static Boolean IBinaryInteger<{1}>.TryReadLittleEndian(ReadOnlySpan<Byte> source, Boolean isUnsigned, out {1} value)
		=> IPrimitiveInteger<{1}, {2}>.TryReadLittleEndian(source, isUnsigned, out value);
}}
#nullable restore";

	private const String binaryIntegerFormattableFormat = @"
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {0} PopCount({0} value) 
		=> IPrimitiveInteger<{0}, {1}>.PopCount(value._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {0} TrailingZeroCount({0} value) 
		=> IPrimitiveInteger<{0}, {1}>.TrailingZeroCount(value._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {0} operator <<({0} value, Int32 shiftAmount) => ({1})(value._value << shiftAmount);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {0} operator >>({0} value, Int32 shiftAmount) => ({1})(value._value >> shiftAmount);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {0} operator >>>({0} value, Int32 shiftAmount) => ({1})(value._value << shiftAmount);";
	private const String binaryCharFormattable = @"
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static JChar IBinaryInteger<JChar>.PopCount(JChar value) => IPrimitiveInteger<JChar, Char>.PopCount(value._value);
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static JChar IBinaryInteger<JChar>.TrailingZeroCount(JChar value) 
		=> IPrimitiveInteger<JChar, Char>.TrailingZeroCount(value._value);
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static JChar IShiftOperators<JChar, Int32, JChar>.operator <<(JChar value, Int32 shiftAmount) 
		=> (Char)(value._value << shiftAmount);
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static JChar IShiftOperators<JChar, Int32, JChar>.operator >>(JChar value, Int32 shiftAmount) 
		=> (Char)(value._value >> shiftAmount);
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	static JChar IShiftOperators<JChar, Int32, JChar>.operator >>>(JChar value, Int32 shiftAmount) 
		=> (Char)(value._value >>> shiftAmount);";

	/// <summary>
	/// Generates operators for numeric structures.
	/// </summary>
	/// <param name="numericSymbol">A type symbol of numeric structure.</param>
	/// <param name="context">Generation context.</param>
	/// <param name="underlineType">Primitive underline type.</param>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void GenerateNumericPrimitiveIntegerOperators(this ISymbol numericSymbol,
		GeneratorExecutionContext context, String underlineType)
	{
		String fileName = $"{numericSymbol.Name}.Integer.g.cs";
		String formattable = numericSymbol.Name is "JChar" ?
			GenerationExtensions.binaryCharFormattable :
			String.Format(GenerationExtensions.binaryIntegerFormattableFormat, numericSymbol.Name, underlineType);
		String source = String.Format(GenerationExtensions.numericIntegerOperatorsFormat,
		                              numericSymbol.ContainingNamespace, numericSymbol.Name, underlineType,
		                              formattable);
		context.AddSource(fileName, source);
	}
}