using System;
using System.Runtime.CompilerServices;

using Microsoft.CodeAnalysis;

namespace Rxmxnx.JNetInterface.SourceGenerator;

internal static partial class GenerationExtensions
{
	private const String numericFloatingPointOperatorsFormat = @"#nullable enable
// <auto-generated/>
namespace {0};

partial struct {1} : IFloatingPointIeee754<{1}>
{{
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	Int32 IFloatingPoint<{1}>.GetExponentByteCount() 
		=> IPrimitiveFloatingPoint<{1}, {2}>.GetExponentByteCount(this._value);
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	Int32 IFloatingPoint<{1}>.GetExponentShortestBitLength() 
		=> IPrimitiveFloatingPoint<{1}, {2}>.GetExponentShortestBitLength(this._value);
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	Int32 IFloatingPoint<{1}>.GetSignificandBitLength() 
		=> IPrimitiveFloatingPoint<{1}, {2}>.GetSignificandBitLength(this._value);
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	Int32 IFloatingPoint<{1}>.GetSignificandByteCount() 
		=> IPrimitiveFloatingPoint<{1}, {2}>.GetSignificandByteCount(this._value);
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	Boolean IFloatingPoint<{1}>.TryWriteExponentBigEndian(Span<Byte> destination, out Int32 bytesWritten)
		=> IPrimitiveFloatingPoint<{1}, {2}>.TryWriteExponentBigEndian(this._value, destination, out bytesWritten);
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	Boolean IFloatingPoint<{1}>.TryWriteExponentLittleEndian(Span<Byte> destination, out Int32 bytesWritten)
		=> IPrimitiveFloatingPoint<{1}, {2}>.TryWriteExponentLittleEndian(this._value, destination, out bytesWritten);
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	Boolean IFloatingPoint<{1}>.TryWriteSignificandBigEndian(Span<Byte> destination, out Int32 bytesWritten)
		=> IPrimitiveFloatingPoint<{1}, {2}>.TryWriteSignificandBigEndian(this._value, destination, out bytesWritten);
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	Boolean IFloatingPoint<{1}>.TryWriteSignificandLittleEndian(Span<Byte> destination, out Int32 bytesWritten)
		=> IPrimitiveFloatingPoint<{1}, {2}>.TryWriteSignificandLittleEndian(this._value, destination, out bytesWritten);
	
	/// <inheritdoc cref=""IFloatingPointIeee754{{TSelf}}.Epsilon""/>
	public static readonly {1} Epsilon = {2}.Epsilon;
	/// <inheritdoc cref=""IFloatingPointIeee754{{TSelf}}.NaN""/>
	public static readonly {1} NaN = {2}.NaN;
	/// <inheritdoc cref=""IFloatingPointIeee754{{TSelf}}.NegativeInfinity""/>
	public static readonly {1} NegativeInfinity = {2}.NegativeInfinity;
	/// <inheritdoc cref=""IFloatingPointIeee754{{TSelf}}.NegativeZero""/>
	public static readonly {1} NegativeZero = {2}.NegativeZero;
	/// <inheritdoc cref=""IFloatingPointIeee754{{TSelf}}.PositiveInfinity""/>
	public static readonly {1} PositiveInfinity = {2}.PositiveInfinity;
	/// <inheritdoc cref=""IFloatingPointConstants{{TSelf}}.E""/>
	public static readonly {1} E = {2}.E;
	/// <inheritdoc cref=""IFloatingPointConstants{{TSelf}}.Pi""/>
	public static readonly {1} Pi = {2}.Pi;
	/// <inheritdoc cref=""IFloatingPointConstants{{TSelf}}.Tau""/>
	public static readonly {1} Tau = {2}.Tau;

	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Atan2({1} y, {1} x) => {2}.Atan2(y._value, x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Atan2Pi({1} y, {1} x) => {2}.Atan2Pi(y._value, x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} BitDecrement({1} x) => {2}.BitDecrement(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} BitIncrement({1} x) => {2}.BitIncrement(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} FusedMultiplyAdd({1} left, {1} right, {1} addend) 
		=> {2}.FusedMultiplyAdd(left._value, right._value, addend._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Ieee754Remainder({1} left, {1} right) 
		=> {2}.Ieee754Remainder(left._value, right._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Int32 ILogB({1} x) => {2}.ILogB(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} ReciprocalEstimate({1} x) => {2}.ReciprocalEstimate(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} ReciprocalSqrtEstimate({1} x) => {2}.ReciprocalSqrtEstimate(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} ScaleB({1} x, Int32 n) => {2}.ScaleB(x._value, n);

	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Exp({1} x) => {2}.Exp(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} ExpM1({1} x) => {2}.ExpM1(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Exp2({1} x) => {2}.Exp2(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Exp2M1({1} x) => {2}.Exp2M1(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Exp10({1} x) => {2}.Exp10(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Exp10M1({1} x) => {2}.Exp10M1(x._value);

	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Ceiling({1} x) =>{2}.Ceiling(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Floor({1} x) =>{2}.Floor(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Round({1} x) =>{2}.Round(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Round({1} x, Int32 digits) =>{2}.Round(x._value, digits);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Round({1} x, MidpointRounding mode) =>{2}.Round(x._value, mode);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Round({1} x, Int32 digits, MidpointRounding mode) =>{2}.Round(x._value, digits, mode);

	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Acosh({1} x) => {2}.Acosh(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Asinh({1} x) => {2}.Asinh(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Atanh({1} x) => {2}.Atanh(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Cosh({1} x) => {2}.Cosh(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Sinh({1} x) => {2}.Sinh(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Tanh({1} x) => {2}.Tanh(x._value);

	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Log({1} x) => {2}.Log(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Log({1} x, {1} newBase) => {2}.Log(x._value, newBase._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} LogP1({1} x) => {2}.LogP1(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Log2P1({1} x) => {2}.Log2P1(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Log10({1} x) => {2}.Log10(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Log10P1({1} x) => {2}.Log10P1(x._value);

	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Pow({1} x, {1} y) => {2}.Pow(x._value, y._value);

	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Cbrt({1} x) => {2}.Cbrt(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Hypot({1} x, {1} y) => {2}.Hypot(x._value, y._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} RootN({1} x, Int32 n) => {2}.RootN(x._value, n);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Sqrt({1} x) => {2}.Sqrt(x._value);

	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Acos({1} x) => {2}.Acos(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} AcosPi({1} x) => {2}.AcosPi(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Asin({1} x) => {2}.Asin(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} AsinPi({1} x) => {2}.AsinPi(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Atan({1} x) => {2}.Atan(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} AtanPi({1} x) => {2}.AtanPi(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Cos({1} x) => {2}.Cos(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} CosPi({1} x) => {2}.CosPi(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Sin({1} x) => {2}.Sin(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ({1} Sin, {1} Cos) SinCos({1} x) => {2}.SinCos(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static ({1} SinPi, {1} CosPi) SinCosPi({1} x) => {2}.SinCosPi(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} SinPi({1} x) => {2}.SinPi(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} Tan({1} x) => {2}.Tan(x._value);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} TanPi({1} x) => {2}.TanPi(x._value);

	static {1} IFloatingPointIeee754<{1}>.Epsilon => {1}.Epsilon;
	static {1} IFloatingPointIeee754<{1}>.NaN => {1}.NaN;
	static {1} IFloatingPointIeee754<{1}>.NegativeInfinity => {1}.NegativeInfinity;
	static {1} IFloatingPointIeee754<{1}>.NegativeZero => {1}.NegativeZero;
	static {1} IFloatingPointIeee754<{1}>.PositiveInfinity => {1}.PositiveInfinity;
	
	static {1} IFloatingPointConstants<{1}>.E => {1}.E;
	static {1} IFloatingPointConstants<{1}>.Pi => {1}.Pi;
	static {1} IFloatingPointConstants<{1}>.Tau => {1}.Tau;

	static {1} ISignedNumber<{1}>.NegativeOne => IPrimitiveSigned<{1}, {2}>.NegativeOne;
}}
#nullable restore";

	/// <summary>
	/// Generates operators for integer structures.
	/// </summary>
	/// <param name="numericSymbol">A type symbol of integer structure.</param>
	/// <param name="context">Generation context.</param>
	/// <param name="underlineType">Primitive underline type.</param>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void GenerateNumericPrimitiveFloatingPointOperators(this ISymbol numericSymbol,
		GeneratorExecutionContext context, String underlineType)
	{
		String fileName = $"{numericSymbol.Name}.FloatingPoint.g.cs";
		String source = String.Format(GenerationExtensions.numericFloatingPointOperatorsFormat,
		                              numericSymbol.ContainingNamespace, numericSymbol.Name, underlineType);
		context.AddSource(fileName, source);
	}
}