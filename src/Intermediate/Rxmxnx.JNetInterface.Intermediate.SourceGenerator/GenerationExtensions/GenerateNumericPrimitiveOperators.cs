using System;
using System.Runtime.CompilerServices;

using Microsoft.CodeAnalysis;

namespace Rxmxnx.JNetInterface.SourceGenerator;

internal static partial class GenerationExtensions
{
	private const String numericPrimitiveOperatorsFormat = @"#nullable enable
// <auto-generated/>
namespace {0};

partial struct {1} : ISpanFormattable, IMinMaxValue<{1}>//, IBinaryNumber<{1}>
{{
	/// <inheritdoc/>
	public static {1} MinValue => {2}.MinValue;
	/// <inheritdoc/>
	public static {1} MaxValue => {2}.MinValue;
{3}

    /// <inheritdoc cref=""IComparisonOperators{{TSelf, TOther, Boolean}}.op_GreaterThan(TSelf, TOther)"" />
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Boolean operator >({1} left, {1} right) => left.CompareTo(right) > 0;
	/// <inheritdoc cref=""IComparisonOperators{{TSelf, TOther, Boolean}}.op_GreaterThanOrEqual(TSelf, TOther)"" />
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Boolean operator >=({1} left, {1} right) => left.CompareTo(right) >= 0;
    /// <inheritdoc cref=""IComparisonOperators{{TSelf, TOther, Boolean}}.op_LessThanOrEqual(TSelf, TOther)"" />
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Boolean operator <=({1} left, {1} right) => left.CompareTo(right) <= 0;
    /// <inheritdoc cref=""IComparisonOperators{{TSelf, TOther, Boolean}}.op_LessThan(TSelf, TOther)"" />
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Boolean operator <({1} left, {1} right) => left.CompareTo(right) < 0;

	/// <inheritdoc cref=""IBitwiseOperators{{TSelf, TOther, TResult}}.op_BitwiseAnd(TSelf, TOther)"" />
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} operator operator &({1} left, {1} right) => left._value & right._value;
	/// <inheritdoc cref=""IBitwiseOperators{{TSelf, TOther, TResult}}.op_BitwiseOr(TSelf, TOther)"" />
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} operator |({1} left, {1} right) => left._value | right._value;
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	/// <inheritdoc cref=""IBitwiseOperators{{TSelf, TOther, TResult}}.op_ExclusiveOr(TSelf, TOther)"" />
	public static {1} operator ^({1} left, {1} right) => left._value ^ right._value;
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	/// <inheritdoc cref=""IBitwiseOperators{{TSelf, TOther, TResult}}.op_OnesComplement(TSelf, TOther)"" />
	public static {1} operator ~({1} value) => ~value._value;

	/// <inheritdoc cref=""IModulusOperators{{TSelf, TOther, TResult}}.op_Modulus(TSelf, TOther)"" />
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static {1} operator %({1} left, {1} right) => left._value % right._value;
}}
#nullable restore";

	private const String numericFormattable = @"
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public String ToString(String? format, IFormatProvider? formatProvider) => this.Value.ToString(format, formatProvider);
	/// <inheritdoc/>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Boolean TryFormat(Span<Char> destination, out Int32 charsWritten, ReadOnlySpan<Char> format, IFormatProvider? provider)
		=> this.Value.TryFormat(destination, out charsWritten, format, provider);";

	private const String charFormattable = @"
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	String IFormattable.ToString(String? format, IFormatProvider? formatProvider) 
		=> ((IFormattable)this.Value).ToString(format, formatProvider);
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	Boolean ISpanFormattable.TryFormat(Span<Char> destination, out Int32 charsWritten, ReadOnlySpan<Char> format, IFormatProvider? provider)
		=> ((ISpanFormattable)this.Value).TryFormat(destination, out charsWritten, format, provider);";

	/// <summary>
	/// Generates operators for numeric structures.
	/// </summary>
	/// <param name="numericSymbol">A type symbol of numeric structure.</param>
	/// <param name="context">Generation context.</param>
	/// <param name="underlineType">Primitive underline type.</param>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void GenerateNumericPrimitiveOperators(this ISymbol numericSymbol, GeneratorExecutionContext context,
		String underlineType)
	{
		String fileName = $"{numericSymbol.Name}.Numeric.g.cs";
		String formattable = numericSymbol.Name != "JChar" ?
			GenerationExtensions.numericFormattable :
			GenerationExtensions.charFormattable;
		String source = String.Format(GenerationExtensions.numericPrimitiveOperatorsFormat,
		                              numericSymbol.ContainingNamespace, numericSymbol.Name, underlineType,
		                              formattable);
		context.AddSource(fileName, source);
	}
}