using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;

namespace Rxmxnx.JNetInterface.SourceGenerator
{
    internal static class GenerationExtensions
    {
        public static INamedTypeSymbol[] GetSourceTypeSymbols(this GeneratorExecutionContext context)
        {
            IList<INamedTypeSymbol> result = new List<INamedTypeSymbol>();
            AppendTypeSymbols(context.Compilation.SourceModule.GlobalNamespace, result);
            return result.ToArray();
        }
        public static String GetLiteralValue(this ISymbol symbol)
        {
            if (!symbol.CanBeReferencedByName) 
                return default;
            
            AttributeData attribute = symbol.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.Name == nameof(DefaultValueAttribute));
            TypedConstant? paramsAttr = (attribute?.ConstructorArguments)?.FirstOrDefault();
            return paramsAttr?.Value as String;

        }
        public static String GetOrdinalSuffix(this Int32 number)
        {
            String textNumber = number.ToString();
            if (textNumber.EndsWith("11")) return "th";
            if (textNumber.EndsWith("12")) return "th";
            if (textNumber.EndsWith("13")) return "th";
            if (textNumber.EndsWith("1")) return "st";
            if (textNumber.EndsWith("2")) return "nd";
            if (textNumber.EndsWith("3")) return "rd";
            return "th";
        }

        public static void GenerateUnicodeConstructor(this GeneratorExecutionContext context, String fullyQualifiedTypeName)
        {
            INamedTypeSymbol typeSymbol = context.Compilation.GetTypeByMetadataName(fullyQualifiedTypeName);
            if (typeSymbol != null)
            {
                StringBuilder strBuild = new StringBuilder();
                foreach (ISymbol symbol in typeSymbol.GetMembers())
                {
                    String value = symbol.GetLiteralValue();
                    if (value != null)
                        strBuild.AppendLine($"\t\t{symbol.Name} = new(() => \"{value}\"u8);");
                }

                context.AddSource($"{typeSymbol.Name}.g.cs", GetGeneratedUnicode(typeSymbol, strBuild));
            }
        }
        public static void GenerateArrayReferenceOperators(this GeneratorExecutionContext context, String fullyQualifiedTypeName)
        {
            context.GenerateObjectReferenceOperator(fullyQualifiedTypeName);
            context.GenerateArrayRefOperators(fullyQualifiedTypeName);
        }
        public static void GenerateObjectReferenceOperator(this GeneratorExecutionContext context, String fullyQualifiedTypeName)
        {
            context.GenerateNativeEquatableOperator(fullyQualifiedTypeName, "_value", !fullyQualifiedTypeName.Contains(".JArrayLocalRef"));
            context.GenerateObjectRefOperators(fullyQualifiedTypeName);
        }
        public static void GenerateNativeEquatableOperator(this GeneratorExecutionContext context, String fullyQualifiedTypeName, String valueName, Boolean overrideEquals = false)
        {
            context.GenerateEquatable(fullyQualifiedTypeName, valueName);
            context.GenerateNativeToString(fullyQualifiedTypeName);
        }
        public static void GenerateNativeToString(this GeneratorExecutionContext context, String fullyQualifiedTypeName)
        {
            INamedTypeSymbol typeSymbol = context.Compilation.GetTypeByMetadataName(fullyQualifiedTypeName);
            if (typeSymbol != null)
            {
                String kind = typeSymbol.TypeKind == TypeKind.Class ? "class" : "struct";
                context.AddSource($"{typeSymbol.Name}.ToString.g.cs", $@"#nullable enable
// <auto-generated/>
namespace {typeSymbol.ContainingNamespace};

partial {kind} {typeSymbol.Name} 
{{
    /// <inheritdoc/>
    public override String{(kind == "struct" ? String.Empty : "?")} ToString() => INative.ToString(this);
}}");
            }
        }

        private static String GetGeneratedUnicode(INamedTypeSymbol typeSymbol, StringBuilder strBuild)
            => $@"#nullable enable
// <auto-generated/>
namespace {typeSymbol.ContainingNamespace};

partial class {typeSymbol.Name} 
{{
	/// <summary>
	/// Static constructor.
	/// </summary>
	static {typeSymbol.Name}()
	{{
{strBuild}	}}
}}";
        private static void AppendTypeSymbols(INamespaceSymbol namespaceSymbol, IList<INamedTypeSymbol> list)
        {
            foreach (INamespaceOrTypeSymbol symbol in namespaceSymbol.GetMembers())
                if (symbol.IsType)
                    list.Add((INamedTypeSymbol)symbol);
                else
                    AppendTypeSymbols((INamespaceSymbol)symbol, list);
        }
        private static void GenerateEquatable(this GeneratorExecutionContext context, String fullyQualifiedTypeName, String valueName)
        {
            INamedTypeSymbol typeSymbol = context.Compilation.GetTypeByMetadataName(fullyQualifiedTypeName);
            if (typeSymbol != null)
            {
                String kind = typeSymbol.TypeKind == TypeKind.Class ? "class" : "struct";
                context.AddSource($"{typeSymbol.Name}.Equals.g.cs", $@"#nullable enable
// <auto-generated/>
namespace {typeSymbol.ContainingNamespace};

partial {kind} {typeSymbol.Name} : IEquatable<{typeSymbol.Name}> 
{{
    /// <inheritdoc/>
    public Boolean Equals({typeSymbol.Name} other) => this.{valueName}.Equals(other.{valueName});

	/// <summary>
    /// Determines whether two specified <see cref=""{typeSymbol.Name}""/> instances have the same value.
    /// </summary>
    /// <param name=""left"">The first <see cref=""{typeSymbol.Name}""/> to compare.</param>
    /// <param name=""right"">The second <see cref=""{typeSymbol.Name}""/> to compare.</param>
    /// <returns>
    /// <see langword=""true""/> if the value of <paramref name=""left""/> is the same as the value 
    /// of <paramref name=""right""/>; otherwise, <see langword=""false""/>.
    /// </returns>
    public static Boolean operator ==({typeSymbol.Name} left, {typeSymbol.Name} right) => left.Equals(right);
    /// <summary>
    /// Determines whether two specified <see cref=""{typeSymbol.Name}""/> instances have different values.
    /// </summary>
    /// <param name=""left"">The first <see cref=""{typeSymbol.Name}""/> to compare.</param>
    /// <param name=""right"">The second <see cref=""{typeSymbol.Name}""/> to compare.</param>
    /// <returns>
    /// <see langword=""true""/> if the value of <paramref name=""left""/> is different from the value  
    /// of <paramref name=""right""/>; otherwise, <see langword=""false""/>.
    /// </returns>
    public static Boolean operator !=({typeSymbol.Name} left, {typeSymbol.Name} right) => !(left == right);
}}");
            }
        }
        private static void GenerateArrayRefOperators(this GeneratorExecutionContext context, String fullyQualifiedTypeName)
        {
            INamedTypeSymbol typeSymbol = context.Compilation.GetTypeByMetadataName(fullyQualifiedTypeName);
            if (typeSymbol != null)
            {
                context.AddSource($"{typeSymbol.Name}.ArrayRef.g.cs", $@"#nullable enable
// <auto-generated/>
namespace {typeSymbol.ContainingNamespace};

partial struct {typeSymbol.Name} : IWrapper<JArrayLocalRef> 
{{
    JArrayLocalRef IWrapper<JArrayLocalRef>.Value => this.ArrayValue;

    /// <summary>
    /// Private constructor.
    /// </summary>
    /// <param name=""arrayRef""><see cref=""JArrayLocalRef""/> value.</param>
    private {typeSymbol.Name}(JArrayLocalRef arrayRef) => this._value = arrayRef;

    /// <summary>
    /// Defines an explicit conversion of a given <see cref=""JArrayLocalRef""/> to <see cref=""{typeSymbol.Name}""/>.
    /// </summary>
    /// <param name=""arrayRef"">A <see cref=""JArrayLocalRef""/> to implicitly convert.</param>
    public static explicit operator {typeSymbol.Name}(JArrayLocalRef arrayRef) => new(arrayRef);

    /// <summary>
    /// Determines whether a specified <see cref=""{typeSymbol.Name}""/> and a <see cref=""JArrayLocalRef""/> instance
    /// have the same value.
    /// </summary>
    /// <param name=""left"">The <see cref=""{typeSymbol.Name}""/> to compare.</param>
    /// <param name=""right"">The <see cref=""JArrayLocalRef""/> to compare.</param>
    /// <returns>
    /// <see langword=""true""/> if the value of <paramref name=""left""/> is the same as the value 
    /// of <paramref name=""right""/>; otherwise, <see langword=""false""/>.
    /// </returns>
    public static Boolean operator ==({typeSymbol.Name} left, JArrayLocalRef right) => left.Equals(right);
    /// <summary>
    /// Determines whether a specified <see cref=""JArrayLocalRef""/> and a <see cref=""{typeSymbol.Name}""/> instance
    /// have the same value.
    /// </summary>
    /// <param name=""left"">The <see cref=""JArrayLocalRef""/> to compare.</param>
    /// <param name=""right"">The <see cref=""{typeSymbol.Name}""/> to compare.</param>
    /// <returns>
    /// <see langword=""true""/> if the value of <paramref name=""left""/> is the same as the value 
    /// of <paramref name=""right""/>; otherwise, <see langword=""false""/>.
    /// </returns>
    public static Boolean operator ==(JArrayLocalRef left, {typeSymbol.Name} right) => left.Equals(right);

    /// <summary>
    /// Determines whether a specified <see cref=""{typeSymbol.Name}""/> and a <see cref=""JArrayLocalRef""/> instance
    /// have different values.
    /// </summary>
    /// <param name=""left"">The <see cref=""{typeSymbol.Name}""/> to compare.</param>
    /// <param name=""right"">The <see cref=""JArrayLocalRef""/> to compare.</param>
    /// <returns>
    /// <see langword=""true""/> if the value of <paramref name=""left""/> is different from the value  
    /// of <paramref name=""right""/>; otherwise, <see langword=""false""/>.
    /// </returns>
    public static Boolean operator !=({typeSymbol.Name} left, JArrayLocalRef right) => !left.Equals(right);
    /// <summary>
    /// Determines whether a specified <see cref=""JArrayLocalRef""/> and a <see cref=""{typeSymbol.Name}""/> instance
    /// have different values.
    /// </summary>
    /// <param name=""left"">The <see cref=""JArrayLocalRef""/> to compare.</param>
    /// <param name=""right"">The <see cref=""{typeSymbol.Name}""/> to compare.</param>
    /// <returns>
    /// <see langword=""true""/> if the value of <paramref name=""left""/> is different from the value  
    /// of <paramref name=""right""/>; otherwise, <see langword=""false""/>.
    /// </returns>
    public static Boolean operator !=(JArrayLocalRef left, {typeSymbol.Name} right) => !left.Equals(right);
}}");
            }
        }
        private static void GenerateObjectRefOperators(this GeneratorExecutionContext context, String fullyQualifiedTypeName)
        {
            INamedTypeSymbol typeSymbol = context.Compilation.GetTypeByMetadataName(fullyQualifiedTypeName);
            if (typeSymbol != null)
            {
                String equalFunction = fullyQualifiedTypeName.Contains("ArrayLocalRef") ?
                    "JArrayLocalRef.ArrayEquals" : "JObjectLocalRef.ObjectEquals";

                context.AddSource($"{typeSymbol.Name}.ObjRef.g.cs", $@"#nullable enable
// <auto-generated/>
namespace {typeSymbol.ContainingNamespace};

partial struct {typeSymbol.Name} 
{{
    /// <summary>
    /// Internal constructor.
    /// </summary>
    /// <param name=""objRef""><see cref=""JObjectLocalRef""/> value.</param>
    internal {typeSymbol.Name}(JObjectLocalRef objRef) => this._value = new(objRef); {(typeSymbol.Name == "JArrayLocalRef" ? String.Empty : $@"
	
    /// <inheritdoc/>
    public override Int32 GetHashCode() => HashCode.Combine(this._value);
    /// <inheritdoc/>
    public override Boolean Equals([NotNullWhen(true)] Object? obj) => {equalFunction}(this, obj);")}

    /// <summary>
    /// Defines an explicit conversion of a given <see cref=""JObjectLocalRef""/> to <see cref=""{typeSymbol.Name}""/>.
    /// </summary>
    /// <param name=""objRef"">A <see cref=""JObjectLocalRef""/> to implicitly convert.</param>
    public static explicit operator {typeSymbol.Name}(JObjectLocalRef objRef) => new(objRef);

    /// <summary>
    /// Determines whether a specified <see cref=""{typeSymbol.Name}""/> and a <see cref=""JObjectLocalRef""/> instance
    /// have the same value.
    /// </summary>
    /// <param name=""left"">The <see cref=""{typeSymbol.Name}""/> to compare.</param>
    /// <param name=""right"">The <see cref=""JObjectLocalRef""/> to compare.</param>
    /// <returns>
    /// <see langword=""true""/> if the value of <paramref name=""left""/> is the same as the value 
    /// of <paramref name=""right""/>; otherwise, <see langword=""false""/>.
    /// </returns>
    public static Boolean operator ==({typeSymbol.Name} left, JObjectLocalRef right) => left.Equals(right);
    /// <summary>
    /// Determines whether a specified <see cref=""JObjectLocalRef""/> and a <see cref=""{typeSymbol.Name}""/> instance
    /// have the same value.
    /// </summary>
    /// <param name=""left"">The <see cref=""JObjectLocalRef""/> to compare.</param>
    /// <param name=""right"">The <see cref=""{typeSymbol.Name}""/> to compare.</param>
    /// <returns>
    /// <see langword=""true""/> if the value of <paramref name=""left""/> is the same as the value 
    /// of <paramref name=""right""/>; otherwise, <see langword=""false""/>.
    /// </returns>
    public static Boolean operator ==(JObjectLocalRef left, {typeSymbol.Name} right) => left.Equals(right);

    /// <summary>
    /// Determines whether a specified <see cref=""{typeSymbol.Name}""/> and a <see cref=""JObjectLocalRef""/> instance
    /// have different values.
    /// </summary>
    /// <param name=""left"">The <see cref=""{typeSymbol.Name}""/> to compare.</param>
    /// <param name=""right"">The <see cref=""JObjectLocalRef""/> to compare.</param>
    /// <returns>
    /// <see langword=""true""/> if the value of <paramref name=""left""/> is different from the value  
    /// of <paramref name=""right""/>; otherwise, <see langword=""false""/>.
    /// </returns>
    public static Boolean operator !=({typeSymbol.Name} left, JObjectLocalRef right) => !left.Equals(right);
    /// <summary>
    /// Determines whether a specified <see cref=""JObjectLocalRef""/> and a <see cref=""{typeSymbol.Name}""/> instance
    /// have different values.
    /// </summary>
    /// <param name=""left"">The <see cref=""JObjectLocalRef""/> to compare.</param>
    /// <param name=""right"">The <see cref=""{typeSymbol.Name}""/> to compare.</param>
    /// <returns>
    /// <see langword=""true""/> if the value of <paramref name=""left""/> is different from the value  
    /// of <paramref name=""right""/>; otherwise, <see langword=""false""/>.
    /// </returns>
    public static Boolean operator !=(JObjectLocalRef left, {typeSymbol.Name} right) => !left.Equals(right);
}}");
            }
        }
    }
}
